
;<CONCURRENT PROGRAMMING IN 8085>

jmp START

START: nop

CALL INITIALIZE

hlt

;----------------------------------------------------------

; VARIABLE DEFINITIONS


; LIST SERVES AS THE PROGRAMS LIST AND STORES
; ALL PROGRAMS PROVIDED BY USER. REMEMBER 
; THAT MAXIMUM NUMBER OF USER PROVIDED PROGRAMS
; CAN BE 12. LIST STORES STARTING ADDRESS OF
; EACH PROGRAM. 

LIST: DB 09000h, 09001h, 09002h, 09003h, 09004h, 09005h, 09006h, 09007h, 09008h, 09009h, 0900Ah, 0900Bh, 0900Ch, 0900Dh, 0900Eh, 0900Fh, 09010h, 09011h, 09012h, 09013h, 09014h, 09015h, 09016h, 09017h

; ALL PROGRAMS ARE INITIALLY INITIALIZED WITH
; VIABLE ADDRESSES FOR EACH PROGRAM. TO
; SERVE AS DEMO, THEY HAVE BEEN SET TO 0s.
 
; INDEX STORES THE ID OF HIGHEST RUNNING
; PROGRAM. IT IS INITIALIZED TO BE 0.
; THEN INITIALIZATION ROUTINE ASSIGNS IT'S 
; CORRESPONDING VALUE.

MAX_INDEX: DB 0

; CURRENT_LOC IS INDEX FOR CURRENT PROGRAM
; EXECUTING, TOTAL_COUNT STORES NUMBER OF 
; PROGRAM(S) TO BE EXECUTED

CURRENT_LOC: DB 0 ; INDEX FOR CURRENT PROGRAM

TOTAL_COUNT: DB 0 ; INDEX FOR NEXT PROGRAM(useless)

; TOP IS THE INDEX FOR TOP OF THE QUEUE
; BOTTOM IS THE INDEX FOR LAST QUEUED JOB

; CURRENT_COUNT IS NUMBER OF JOBS RUNNING RIGHT
; NOW, QUEUE CONTAINS ALL PROGRAMS, WHICH ARE
; RUNNING CURRENTLY, i.e., IT SERVES AS THE
; RUNNING QUEUE

QUEUE: DB 0A789h, 0A78Ah, 0A78Bh, 0A78Ch, 0A78Dh, 0A78Dh, 0A78Eh, 0A78Fh, 0A790h, 0A791h, 0A792h, 0A793h, 0A794h 
; 12 ZEROES CORRESPONDING 12-BYTES FOR JOB QUEUE

CURRENT_COUNT: DB 4 ; INITIALIZE WILL RESET IT

TOP: DB 1 ; INDEX FOR NEXT JOB TO BE DEQUEUED

BOTTOM: DB 0 ; INDEX FOR NEXT JOB TO BE ENQUEUED(useless)

; BACKUP SERVES AS BACKUP FOR ACCUMULATOR
; WHILE PERFORMING OTHER OPERATIONS

BACKUP1: DB 0 ; 1ST BYTE
BACKUP2: DB 0 ; 2ND BYTE(useless)

;----------------------------------------------------------

; INITIALIZATION SUB-ROUTINE


; IT IS THE MAIN PROGRAM WHICH WILL BE
; RUNNING AND WILL HANDLE CONTEXT SWITCHING,
; WHEN TIMER BASED INTERRUPTS ARE RECEIVED.
; IT'S FIRST TASK IS TO PICK TASKS TO RUN FROM 
; GIVEN LIST OF TASKS.

INITIALIZE: NOP

DI ; DISABLE INTERRUPTS 
CALL VERIFY

RET

; VERIFY WHETHER PROGRAM IS PRESENT OR NOT

VERIFY: NOP
 
; LOAD PROGRAM LOCATION

LDA 020h ; FIRST BYTE OF ADDRESS OF LIST
MOV D, A
LDA MAX_INDEX
ADD D
ADD D
MOV L, A
LDA 081h
MOV H, A

; LOAD PROGRAM INSTRUCTION

MOV A, M

; CHECKS FIRST INSTRUCTION OF PROGRAM AGAINST ZERO

CPI 0 
JNZ SETUP ; IF NOT ZERO, THEN SETS UP STACK
JZ RUN_MODE ; IF ZERO, THEN STARTX EXECUTION

; INCREMENT MAX_INDEX, i.e., NUMBER OF PROGRAMS SET
; FOR EXECUTION
 
LDA MAX_INDEX
ADI 1
STA MAX_INDEX
CPI 6
JZ RUN_MODE
JNZ VERIFY ; IF NOT 6, THEN VERIFY NEXT PROGRAM

RET

; SET P1 AS RUNNING PROGRAM

RUN_MODE: NOP 

	MVI H, 081h ; FIRST BYTE OF LIST ADDRESS 
	MVI L, 020h ; SECOND BYTE OF LIST ADDRESS

	LXI SP, 0A789h ; SET STACK FOR FIRST PROGRAM
	PUSH H

RET
 	
; SET UP STACK

SETUP: NOP	

; MOVE PROGRAM LOCATION TO B, C
	
MOV B, H
MOV C, L
  
; GET STACK POINTER IN H, P

MVI H, 081h ; FIRST BYTE OF QUEUE ADDRESS 
MVI L, 00h ; SECOND BYTE OF QUEUE ADDRESS
LDA MAX_INDEX
ADD H
ADD H
MOV H, A 
ADI 1
MOV L , A ; H, L STORES ADDRESS OF REQUIRED SP

; SET STACK

SPHL 

PUSH B ; PROGRAM LOCATION IS PUSHED

MVI H, 0 ; RESET H, L
MVI L, 0
 
PUSH H
PUSH H
PUSH H
PUSH H ; ALL REGISTERS PUSHED AS 0 INITIALLY

; UPDATE STACK POINTER AT LOCATION

; MOVE SP TO B, C
MVI H, 0
MVI L, 0
DAD SP
MOV B, H
MOV C, H

; UPDATE STACK POINTER 

MVI H, 081h ; FIRST BYTE OF QUEUE ADDRESS 
MVI L, 00h ; SECOND BYTE OF QUEUE ADDRESS
LDA CURRENT_LOC
ADD H
ADD H
MOV H, A 
ADI 1
MOV L , A ; H, L STORES ADDRESS OF REQUIRED LOCATION IN QUEUE
MOV M, B ; B MOVED TO M
ADI 1
MOV H, A
ADI 1
MOV L, A
MOV M, C ; SECOND BYTE OF SP IS UPDATED IN QUEUE

LXI SP, 0FFFFh

RET ; RETURN CONTROL TO VERIFY

;----------------------------------------------------------

; SUB-ROUTINE FOR CONTEXT_SWITCHING


; SWITCHES BETWEEN TWO PROGRAMS WHENEVER
; TIMER BASED INTERRUPT IS RECEIVED

CONTEXT_SWITCH: NOP

DI ; DISABLE INTERRUPTS

; PUSH REGISTER PAIRS INTO STACK IN B,
; D, H ORDER

PUSH B
PUSH D
PUSH H

; PUSH PROGRAM STATUS WORD

PUSH PSW

; UPDATE STACK POINTER AT LOCATION

; MOVE SP TO B, C
MVI H, 0
MVI L, 0
DAD SP
MOV B, H
MOV C, L

; MOVE STACK POINTER

MVI H, 081h ; FIRST BYTE OF QUEUE ADDRESS 
MVI L, 00h ; SECOND BYTE OF QUEUE ADDRESS
LDA CURRENT_LOC
ADD H
ADD H
MOV H, A 
ADI 1
MOV L , A ; H, L STORES ADDRESS OF REQUIRED LOCATION IN QUEUE
MOV M, B ; B MOVED TO M
ADI 1
MOV H, A
ADI 1
MOV L, A
MOV M, C ; SECOND BYTE OF SP IS UPDATED IN QUEUE

; NOW, QUEUE IS UPDATED BY NEW VALUE OF SP

; PERFORM QUEUEING OPERATIONS

CALL ENQUEUE ; PERFORM ENQUEUE OPERATION(useless)
CALL DEQUEUE ; PERFORM DEQUEUE OPERATION

; MOVE STACK POINTER CORRESPONDING TO 
; NEW JOB

LDA TOP
MOV B, A
MVI H, 081h ; FIRST BYTE OF QUEUE ADDRESS
MVI L, 00h ; SECOND BYTE OF QUEUE ADDRESS
MOV A, L
ADD B
ADD B
MOV L, A
ADI 1
MOV H, A ; H, L CONTAINS ADDRESS OF NEXT SP
SPHL

; POP PROGRAM STATUS WORD

POP PSW

; POP REGISTER PAIRS IN REVERSE ORDER AS
; COMPARED TO THEIR PUSH ORDER

POP H
POP D
POP B

EI ; ENABLE INTERRUPTS

RET ; RETURN CONTROL TO MAIN PROGRAM

;----------------------------------------------------------

; QUEUE OPERATIONS


; ENQUEUE OPERATION DOES NOTHING
; DEQUEUE OPERATION, FIRST ASSIGNS CURRENT_LOC
; SAME VALUE AS TOP, THEN CHANGES THE VALUE OF 
; TOP AS REQUIRED

ENQUEUE: NOP ; DO NOTHING(useless)

RET ; RETURN CONTROL TO CONTEXT_SWITCH PROGRAM

DEQUEUE: NOP  ; SET CURRENT_LOC AND CHANGE TOP

STA BACKUP1
LDA TOP
STA CURRENT_LOC ; SET CURRENT_LOC = TOP

; CHANGE TOP INDEX

MOV B, A
LDA CURRENT_COUNT

CMP B ; USING VARIABLE DOESN'T WORKS
JZ RESET
JNZ INCREMENT

LDA BACKUP1

RET ; RETURN CONTROL TO CONTEXT_SWITCH PROGRAM

; RESET TOP INDEX

RESET: NOP

MVI A, 0
STA TOP

RET ; RETURN CONTROL TO DEQUEUE PROGRAM

; INCREMENT TOP INDEX

INCREMENT: NOP

MOV A, B
INR A
STA TOP

RET ; RETURN CONTROL TO DEQUEUE PROGRAM

;----------------------------------------------------------

; TERMINATION AND TRANSFER OF CONTROL FOR PROGRAMS


; TERMINATE IS CALLED, WHEN A PROGRAM IS TERMINATED
; IT IS A REPLACEMENT PROVIDED TO BE USED INSTEAD OF 
; HLT OR RET INSTRUCTIONS

TERMINATE: NOP

LDA CURRENT_COUNT
MOV B, A
LDA TOTAL_COUNT
CMP B
JZ HALTING
JNZ ADD_NEW

RET ; RETURN TO EXECUTION

; HALTING STOPS EXECUTION CHAIN

HALTING: NOP

HLT ; HALTS 8085

; ADD_NEW ADDS NEW PROGRAM TO EXECUTION QUEUE

ADD_NEW: NOP



RET ; RETURN CONTROL TO TERMINATE
