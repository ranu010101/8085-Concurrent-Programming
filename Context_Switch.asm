
;<CONCURRENT PROGRAMMING IN 8085>

jmp START

START: nop

hlt

;----------------------------------------------------------

; VARIABLE DEFINITIONS


; LIST SERVES AS THE PROGRAMS LIST AND STORES
; ALL PROGRAMS PROVIDED BY USER. REMEMBER 
; THAT MAXIMUM NUMBER OF USER PROVIDED PROGRAMS
; CAN BE 12. LIST STORES STARTING ADDRESS OF
; EACH PROGRAM. 

LIST: DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

; ALL PROGRAMS ARE INITIALLY INITIALIZED WITH
; VIABLE ADDRESSES FOR EACH PROGRAM. TO
; SERVE AS DEMO, THEY HAVE BEEN SET TO 0s.
 
; INDEX STORES THE ID OF HIGHEST RUNNING
; PROGRAM. IT IS INITIALIZED TO BE 0.
; THEN INITIALIZATION ROUTINE ASSIGNS IT'S 
; CORRESPONDING VALUE.

MAX_INDEX: DB 0

; CURRENT_LOC IS INDEX FOR CURRENT PROGRAM
; EXECUTING, NEW_LOC STORES INDEX FOR NEXT 
; PROGRAM TO BE EXECUTED

CURRENT_LOC: DB 0 ; INDEX FOR CURRENT PROGRAM

NEW_LOC: DB 0 ; INDEX FOR NEXT PROGRAM(useless)

; TOP IS THE INDEX FOR TOP OF THE QUEUE
; BOTTOM IS THE INDEX FOR LAST QUEUED JOB

; CURRENT_COUNT IS NUMBER OF JOBS RUNNING RIGHT
; NOW, QUEUE CONTAINS ALL PROGRAMS, WHICH ARE
; RUNNING CURRENTLY, i.e., IT SERVES AS THE
; RUNNING QUEUE

QUEUE: DB 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
; 12 ZEROES CORRESPONDING 12-BYTES FOR JOB QUEUE

CURRENT_COUNT: DB 4 ; INITIALIZE WILL RESET IT

TOP: DB 1 ; INDEX FOR NEXT JOB TO BE DEQUEUED

BOTTOM: DB 0 ; INDEX FOR NEXT JOB TO BE ENQUEUED(useless)

; BACKUP SERVES AS BACKUP FOR ACCUMULATOR
; WHILE PERFORMING OTHER OPERATIONS

BACKUP1: DB 0 ; 1ST BYTE
BACKUP2: DB 0 ; 2ND BYTE(useless)

;----------------------------------------------------------

; INITIALIZATION SUB-ROUTINE


; IT IS THE MAIN PROGRAM WHICH WILL BE
; RUNNING AND WILL HANDLE CONTEXT SWITCHING,
; WHEN TIMER BASED INTERRUPTS ARE RECEIVED.
; IT'S FIRST TASK IS TO PICK TASKS TO RUN FROM 
; GIVEN LIST OF TASKS.

INITIALIZE: NOP

DI ; DISABLE INTERRUPTS 

VERIFY:
	LDA LIST
	ADD MAX_INDEX
	MOV H, A
	ADI 1
	MOV L, A
	MOV A, M
	CPI 0
	JNZ SETUP
	JZ RUN_MODE
	LDA MAX_INDEX
	ADI 1
	STA MAX_INDEX
	JMP VERIFY

RUN_MODE: ; SET P1 AS RUNNING PROGRAM
	LXI SP, QUEUE
	POP PSW
	POP H
	POP D
	POP B

SETUP: NOP


PUSH PC


;----------------------------------------------------------

; SUB-ROUTINE FOR CONTEXT_SWITCHING


; SWITCHES BETWEEN TWO PROGRAMS WHENEVER
; TIMER BASED INTERRUPT IS RECEIVED

CONTEXT_SWITCH: NOP

DI ; DISABLE INTERRUPTS

; PUSH REGISTER PAIRS INTO STACK IN B,
; D, H ORDER

PUSH B
PUSH D
PUSH H

; PUSH PROGRAM STATUS WORD

PUSH PSW

; PERFORM QUEUEING OPERATIONS

CALL ENQUEUE ; PERFORM ENQUEUE OPERATION(useless)
CALL DEQUEUE ; PERFORM DEQUEUE OPERATION

; MOVE STACK POINTER CORRESPONDING TO 
; NEW JOB

LDA TOP
MOV B, A
LDA QUEUE
ADD B
ADD B
MOV H, A
ADI 1
MOV L, A ; H, L CONTAINS ADDRESS OF NEXT SP
SPHL

; POP PROGRAM STATUS WORD

POP PSW

; POP REGISTER PAIRS IN REVERSE ORDER AS
; COMPARED TO THEIR PUSH ORDER

POP H
POP D
POP B

EI ; ENABLE INTERRUPTS

RET ; RETURN CONTROL TO MAIN PROGRAM

;----------------------------------------------------------

; QUEUE OPERATIONS


; ENQUEUE OPERATION DOES NOTHING
; DEQUEUE OPERATION, FIRST ASSIGNS CURRENT_LOC
; SAME VALUE AS TOP, THEN CHANGES THE VALUE OF 
; TOP AS REQUIRED

ENQUEUE: NOP ; DO NOTHING(useless)

RET ; RETURN CONTROL TO CONTEXT_SWITCH PROGRAM

DEQUEUE: NOP  ; SET CURRENT_LOC AND CHANGE TOP

STA BACKUP1
LDA TOP
STA CURRENT_LOC ; SET CURRENT_LOC = TOP

; CHANGE TOP INDEX

MOV B, A
LDA CURRENT_COUNT

CMP B ; USING VARIABLE DOESN'T WORKS
JZ RESET
JNZ INCREMENT

LDA BACKUP1

RET ; RETURN CONTROL TO CONTEXT_SWITCH PROGRAM

; RESET TOP INDEX

RESET: NOP

MVI A, 0
STA TOP

RET ; RETURN CONTROL TO DEQUEUE PROGRAM

; INCREMENT TOP INDEX

INCREMENT: NOP

MOV A, B
INR A
STA TOP

RET ; RETURN CONTROL TO DEQUEUE PROGRAM

;----------------------------------------------------------

; TERMINATION AND TRANSFER OF CONTROL FOR PROGRAMS


; TERMINATE IS CALLED, WHEN A PROGRAM IS TERMINATED
; IT IS A REPLACEMENT PROVIDED TO BE USED INSTEAD OF 
; HLT OR RET INSTRUCTIONS

TERMINATE: NOP

